#!/usr/bin/env ruby

require 'rainbow'
require 'rainbow/ext/string'
require 'optparse'
require 'log_tagger'
require 'slop'

DEFAULT_LOGTAGS_FILENAME = "Logtags"

begin
  opts = Slop.parse :help => true do
    banner "Usage: #{$0} [command] [options] files"

    command "tag" do
      description "Tag all lines without filtering or applying tranformations"

      run do |opts, args|
        options =  opts.to_hash
        options[:definitions] ||= DEFAULT_LOGTAGS_FILENAME
        load options[:definitions]

        description = LogTagger::TagsDescription.new(LogTagger.definitions)

        ARGF.each do |line|
          tags = description.matching_tags_for_line(LogTagger.definitions.keys, line)
          puts "#{tags.collect{ |t| description.rule(t).label }.join}#{line}"
        end
      end

    end

    command 'filter' do
      description "Filter lines in log file by tags"
      on :i, :include=, 'Include Tags',  as: Array, delimiter: '|', required: true
      on :n, "no-labels", 'Do not display label'
      on :d, :definitions=, "Logtags file with Tag definitions"

      run do |opts, args|
        options =  opts.to_hash
        options[:definitions] ||= DEFAULT_LOGTAGS_FILENAME
        options[:include].collect!{|v| LogTagger::PlanEntry.new(v) } if options[:include]
        load options[:definitions]

        description = LogTagger::TagsDescription.new(LogTagger.definitions)
        plan = LogTagger::Plan.new(description, options)

        ARGF.each do |line|
          match = plan.match(line)

          match.print_line if match
        end
        # exit
      end
    end

    command 'count' do
      description 'Count tags on log file'

      on :i, :include=, 'Include Tags',  as: Array, delimiter: '|'
      on :d, :definitions=, "Logtags file with Tag definitions"
      on :l, :logs=, "Log input files"

      run do |opts, args|
        options =  opts.to_hash
        options[:include].collect!{|v| LogTagger::PlanEntry.new(v) } if options[:include]
        options[:definitions] ||= DEFAULT_LOGTAGS_FILENAME
        load options[:definitions]

        tags = {}
        description = LogTagger::TagsDescription.new(LogTagger.definitions)

        tags_for_line = nil
        ARGF.each do |line|
          unless options[:include]
            tags_for_line = description.matching_tags_for_line(LogTagger.definitions.keys,line)

            tags_for_line.each do |t|
              tags[t] ||= 0
              tags[t] += 1
            end
          else
            tags_for_line = description.matching_tags_for_line(LogTagger.definitions.keys,line)
            options[:include].each do |e|
              if e.match(tags_for_line)
                  tags[e] ||=0
                  tags[e] +=1
              end
            end
          end
        end

        tags.each do |k,v|
          case k
          when Symbol
            r = description.rule(k)
            puts "#{v}\t#{r.label}"
          when LogTagger::PlanEntry
            puts "#{v}\t#{k.include_tags.collect{|t| description.rule(t).label }.join }"
          end
        end
        # exit
      end
    end

    command 'summary' do
      on :d, :definitions=, "Logtags file with Tag definitions"

      description 'List tag definitions available'
      run do |opts, args|
        options =  opts.to_hash
        options[:definitions] ||= DEFAULT_LOGTAGS_FILENAME
        load options[:definitions]
        description = LogTagger::TagsDescription.new(LogTagger.definitions)

        description.tags.each do |entry|
          puts "#{entry.label} => #{entry.match_regex.to_s}"
        end

        exit
      end
    end
  end
  # puts "Command not found"
  # puts opts
rescue Slop::MissingOptionError => e
  $stderr.puts e.to_s.color(:red)
end
